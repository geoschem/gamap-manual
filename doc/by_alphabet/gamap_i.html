<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>I routines</TITLE>
</head>
 
<body bgcolor="#FFFFFF">
<H1>I routines</H1>
<P>
 
 
 



<P><a href="../all_routines/All_GAMAP_Routines.html">All GAMAP Routines</a></p>

<P>List routines by category:<br>
<a href="../by_category/AtmosphericSciences.html">Atmospheric Sciences</a> | 
<a href="../by_category/Benchmarking.html">Benchmarking</a> | 
<a href="../by_category/Color.html">Color</a> | 
<a href="../by_category/DateAndTime.html">Date/Time</a> | 
<a href="../by_category/Documentation.html">Doc</a> | 
<a href="../by_category/FileAndIO.html">File &amp; I/O</a> | 
<a href="../by_category/BpchFormat.html">BPCH Format </a> | 
<a href="../by_category/ScientificDataFormats.html">Scientific Data Formats</a> | 
<a href="../by_category/GamapExamples.html">GAMAP Examples</a> | 
<a href="../by_category/GamapInternals.html">GAMAP Internals</a> | 
<a href="../by_category/GamapUtilities.html">GAMAP Utilities</a> | 
<a href="../by_category/GamapDataManipulation.html">GAMAP Data Manipulation</a> | 
<a href="../by_category/GamapModelsAndGrids.html">GAMAP Models &amp;
Grids</a> | 
<a href="../by_category/GamapPlotting.html">GAMAP Plotting</a> | 
<a href="../by_category/General.html">General</a> | 
<a href="../by_category/Graphics.html">Graphics</a> | 
<a href="../by_category/MathAndUnits.html">Math &amp; Units</a> | 
<a href="../by_category/Plotting.html">Plotting</a> | 
<a href="../by_category/Regridding.html">Regridding</a> | 
<a href="../by_category/Strings.html">Strings</a> | 
<a href="../by_category/Structures.html">Structures</a> | 
<a href="../by_category/Timeseries.html">Time Series</a></p>

<P>List routines by alphabetical order:<br>
<a href="../by_alphabet/gamap_a.html">A</a> | 
<a href="../by_alphabet/gamap_b.html">B</a> | 
<a href="../by_alphabet/gamap_c.html">C</a> | 
<a href="../by_alphabet/gamap_d.html">D</a> | 
<a href="../by_alphabet/gamap_e.html">E</a> | 
<a href="../by_alphabet/gamap_f.html">F</a> | 
<a href="../by_alphabet/gamap_g.html">G</a> | 
<a href="../by_alphabet/gamap_h.html">H</a> | 
<a href="../by_alphabet/gamap_i.html">I</a> | 
<a href="../by_alphabet/gamap_j.html">J</a> | 
<a href="../by_alphabet/gamap_k.html">K</a> | 
<a href="../by_alphabet/gamap_l.html">L</a> | 
<a href="../by_alphabet/gamap_m.html">M</a> | 
<a href="../by_alphabet/gamap_n.html">N</a> | 
<a href="../by_alphabet/gamap_o.html">O</a> | 
<a href="../by_alphabet/gamap_p.html">P</a> | 
<a href="../by_alphabet/gamap_q.html">Q</a> | 
<a href="../by_alphabet/gamap_r.html">R</a> | 
<a href="../by_alphabet/gamap_s.html">S</a> | 
<a href="../by_alphabet/gamap_t.html">T</a> | 
<a href="../by_alphabet/gamap_u.html">U</a> | 
<a href="../by_alphabet/gamap_v.html">V</a> | 
<a href="../by_alphabet/gamap_w.html">W</a> | 
X | 
<a href="../by_alphabet/gamap_y.html">Y</a> | 
<a href="../by_alphabet/gamap_z.html">Z</a></p>
<STRONG>Last modified: </STRONG>Tue Apr  4 10:50:25 2017.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#IDL2HTML">IDL2HTML</A>
<LI><A HREF="#IMAGE_MAP">IMAGE_MAP</A>
<LI><A HREF="#IND_COMB">IND_COMB</A>
<LI><A HREF="#INTERPOLATE_2D">INTERPOLATE_2D</A>
<LI><A HREF="#INV_INDEX">INV_INDEX</A>
<LI><A HREF="#IN_RANGE">IN_RANGE</A>
<LI><A HREF="#ISALGEBRAIC (FUNCTION)">ISALGEBRAIC (FUNCTION)</A>
<LI><A HREF="#ISALNUM (FUNCTION)">ISALNUM (FUNCTION)</A>
<LI><A HREF="#ISALPHA (FUNCTION)">ISALPHA (FUNCTION)</A>
<LI><A HREF="#ISDIGIT (FUNCTION)">ISDIGIT (FUNCTION)</A>
<LI><A HREF="#ISGRAPH (FUNCTION)">ISGRAPH (FUNCTION)</A>
<LI><A HREF="#ISLEAP (FUNCTION)">ISLEAP (FUNCTION)</A>
<LI><A HREF="#ISLOWER (FUNCTION)">ISLOWER (FUNCTION)</A>
<LI><A HREF="#ISOPLETH_MAP">ISOPLETH_MAP</A>
<LI><A HREF="#ISPRINT (FUNCTION)">ISPRINT (FUNCTION)</A>
<LI><A HREF="#ISSPACE (FUNCTION)">ISSPACE (FUNCTION)</A>
<LI><A HREF="#ISUPPER (FUNCTION)">ISUPPER (FUNCTION)</A>
<LI><A HREF="#IS_DEFINED">IS_DEFINED</A>
<LI><A HREF="#IS_DIR (FUNCTION)">IS_DIR (FUNCTION)</A>
<LI><A HREF="#IS_SELECTED (FUNCTION)">IS_SELECTED (FUNCTION)</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="IDL2HTML">
<H2>IDL2HTML</H2></A>
<A HREF="#IMAGE_MAP">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        IDL2HTML

 PURPOSE:
        Wrapper for MK_HTML_HELP.  Can be used to create HTML files
        which contain the comments from the standard doc headers
        that are included with each IDL routine.

 CATEGORY:
        Documentation

 CALLING SEQUENCE:
        IDL2HTML, PATH, [ , Keywords ]

 INPUTS:
        PATH -> A file path (can be a directory, single file name,
             or file mask) for the IDL routines whose doc headers
             you wish to convert to HTML format.

 KEYWORD PARAMETERS:
        /ALPHABETICAL -> Set this switch to create a separate HTML 
             documentation file for files beginning with each letter
             of the alphabet.  This is useful if you have a lot of
             files to process.

        /CATEGORY -> If specified, IDL2HTML will create a HTML file
             for all *.pro files corresponding to a given category
             (as specified by the CATEGORY tag in the standard
              IDL documentation headers).

        HTMLFILE -> Name of the HTML file that will be created.
             A default file name will be used if HTMLFILE is omitted.

        OUTDIR -> Name of the directory into which the HTML
             documentation files will be written.

        _EXTRA=e -> Passes extra keywords to MK_HTML_HELP.

 OUTPUTS:
        None

 SUBROUTINES:
        External Subroutines Required:
        =======================================================
        ADD_SEPARATOR (function)   EXTRACT_FILENAME (function)
        IS_DIR (function)          STRWHERE         (function)

 REQUIREMENTS:
        None

 NOTES:
        None

 EXAMPLE:
        IDL2HTML, '~/IDL/tools/', OUTDIR='~/doc/html/', /ALPHABETICAL

             ; Will create HTML files with documentation from the
             ; IDL routines in the ~/IDL/tools directory.  Will
             ; place the output in the ~/doc/html directory.

 MODIFICATION HISTORY:
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/doc/idl2html.pro)</STRONG><P>
<HR>
 
<A NAME="IMAGE_MAP">
<H2>IMAGE_MAP</H2></A>
<A HREF="#IDL2HTML">[Previous Routine]</A>
<A HREF="#IND_COMB">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	IMAGE_MAP

 PURPOSE:
	Overlay an image and a map (satellite projection)

 CATEGORY:
	Plotting

 CALLING SEQUENCE:
	IMAGE_MAP, A

 INPUTS:
	A -> The two-dimensional array to display.

 KEYWORD PARAMETERS:
       WINDOW_SCALE -> Set this keyword to scale the window size to 
           the image size. Otherwise, the image size is scaled to 
           the window size.  This keyword is ignored when outputting 
           to devices with scalable pixels (e.g., PostScript).
           [original as in image_contour]

	ASPECT-> Set this keyword to retain the image's aspect ratio.
	    Square pixels are assumed.  If WINDOW_SCALE is set, the 
	    aspect ratio is automatically retained.
           [original as in image_contour]

	INTERP -> If this keyword is set, bilinear interpolation 
           is used if the image is resized.
           [original as in image_contour]

       CENTERX -> longitudinal position of geostationary satellite
           (default -135 = GEOS-9)

       DIST -> distance of satellite from Earth surface (in earth radii)
           (default = 7)

       CONTINENTS -> superimpose map continents on the image

 OUTPUTS:
	No explicit outputs.

 COMMON BLOCKS:
	None

 SIDE EFFECTS:
	The currently selected display is affected.

 RESTRICTIONS:
	None

 NOTES:
       Derived from IDL routine image_contour.
       Not very flexible - quick hack to analyze PEM-T data

 PROCEDURE:
	If the device has scalable pixels, then the image is written over
	the plot window.

 MODIFICATION HISTORY:
	 mgs, 01 Oct 1997: based on IMAGE_CONT by DMS, May, 1988.
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/plotting/image_map.pro)</STRONG><P>
<HR>
 
<A NAME="IND_COMB">
<H2>IND_COMB</H2></A>
<A HREF="#IMAGE_MAP">[Previous Routine]</A>
<A HREF="#INTERPOLATE_2D">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        IND_COMB

 PURPOSE:
        Combine two index arrays that result from different
        WHERE calls to the same data set.

 CATEGORY:
        General

 CALLING SEQUENCE:
        RESULT = IND_COMB( INDEX1, INDEX2, TYPE [, keywords ] )

 INPUTS:
        INDEX1, INDEX2 --> the two index arrays (may be single 
             integers or -1, but must be given)

        TYPE --> a string containing the type of index combination:
             The result will contain an index value if the index is 
             contained in ...
               type eq "OR":   ... at least one of INDEX1 or INDEX2
               type eq "AND":  ... INDEX1 and INDEX2
               type eq "NOR":  ... neither INDEX1 nor INDEX2
               type eq "XOR":  ... only one of INDEX1 or INDEX2
               type eq "NAND": ... not in both
             The default combination is "OR".

 KEYWORD PARAMETERS:
        TOTALN --> optional: number of elements in the data set. 
             If not given, this value is calculated as 
             max([index1,index2]).  If this argument is passed, 
             the user has full responsibility that array indices 
             are not exceeded.  ATTENTION: types NAND and NOR may 
             give wrong results if TOTALN is not specified 
             (see example).

 OUTPUTS:
        RESULT -> An array of type lon that contains the combined 
             indices and can be used as an array subscript.

 SUBROUTINES:
        None

 REQUIREMENTS:
        None

 NOTES:
        None

 EXAMPLE:
        DATA = FINDGEN(100)+1
        IND1 = WHERE(DATA le 50)
        IND2 = WHERE(DATA ge 50 AND DATA lt 80)

        RES = IND_COMB(IND1,IND2,"OR")
            print,'1:',min(data(res)),max(data(res)) 

        RES = IND_COMB(IND1,IND2,"AND")
            print,'2:',min(data(res)),max(data(res))

        RES = IND_COMB(IND1,IND2,"NOR")   ; <------  WRONG !!
            print,'3:',res                         

        RES = IND_COMB(IND1,IND2,"NOR",TOTALN=100)
            print,'4:',min(data(res)),max(data(res))

        RES = IND_COMB(IND1,IND2,"XOR")
            print,'5:',min(data(res)),max(data(res))

        RES = IND_COMB(IND1,IND2,"NAND")  ; <------  WRONG !!
            print,'6:',min(data(res)),max(data(res))

        RES = IND_COMB(IND1,IND2,"NAND",TOTALN=100)
            print,'7:',min(data(res)),max(data(res))

        IDL will print:
            1:  1    79
            2: 50    50 
            3: -1           <------  WRONG !!
            4: 80   100
            5:  1    79
            6:  1    79     <------  WRONG !!
            7:  1   100

 MODIFICATION HISTORY:
        mgs, 04 Dec 1997: VERSION 1.00
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10
                          - updated comments, cosmetic changes

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/general/ind_comb.pro)</STRONG><P>
<HR>
 
<A NAME="INTERPOLATE_2D">
<H2>INTERPOLATE_2D</H2></A>
<A HREF="#IND_COMB">[Previous Routine]</A>
<A HREF="#INV_INDEX">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        INTERPOLATE_2D

 PURPOSE:
        Interpolates a 2-D array from one grid to another.

 CATEGORY:
        Regridding

 CALLING SEQUENCE:
        NEWDATA = INTERPOLATE_2D( DATA,    OLDXMID, OLDYMID,    $
                                  NEWXMID, NEWYMID  [, Keywords ] )

 INPUTS:
        DATA -> A 2-D array containing the data to be interpolated.

        OLDXMID -> A 1-D vector containing the X-coordinates (e.g. 
             longitude) corresponding to the DATA array.

        OLDYMID -> A 1-D vector containing the Y-coordinates (e.g. 
             latitude) corresponding to the DATA array.

        NEWXMID -> A 1-D vector containing the X-coordinates (e.g. 
             longitude) of the new grid onto which DATA will be 
             interpolated.

        NEWYMID -> A 1-D vector containing the Y-coordinates (e.g. 
             latitude) of the new grid onto which DATA will be 
             interpolated.

 KEYWORD PARAMETERS:
        /DOUBLE -> Set this switch to force computation in double 
             precision.  Default is to use single precision.

 OUTPUTS:
        NEWDATA -> A 2-D array containing the data on the new grid.

 SUBROUTINES:
        None

 REQUIREMENTS:
        None

 NOTES:
        INTERPOLATE_2D can be used to interpolate from coarse grids
        to fine grids or fine grids to coarse grids.  This routine
        uses the IDL INTERPOL command.
    
 EXAMPLE:

        ; Define old grid (GEOS-Chem 2x25)
        OLDTYPE  = CTM_TYPE( 'GEOS4', RES=2 )
        OLDGRID  = CTM_GRID( OLDTYPE        )

        ; Define new grid (GEOS-Chem 4x5)
        NEWTYPE  = CTM_TYPE( 'GEOS4', RES=4 )
        NEWGRID  = CTM_GRID( NEWTYPE        )

        ; Interpolate DATA array from 2x25 to 4x5
        NEWDATA  = INTERPOLATE_2D( DATA,                       $
                                   OLDGRID.XMID, OLDGRID.YMID, $
                                   NEWGRID.XMID, NEWGRID.YMID )

             ; Interpolate a data array from the GEOS-Chem 
             ; 2 x 2.5 grid to the GEOS-Chem 4 x 5 grid
        
 MODIFICATION HISTORY:
  bmy & phs, 20 Jun 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/regridding/interpolate_2d.pro)</STRONG><P>
<HR>
 
<A NAME="INV_INDEX">
<H2>INV_INDEX</H2></A>
<A HREF="#INTERPOLATE_2D">[Previous Routine]</A>
<A HREF="#IN_RANGE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        INV_INDEX

 PURPOSE:
        Find the indices that do NOT match a WHERE condition

 CATEGORY:
        General

 CALLING SEQUENCE:
        RESULT = INV_INDEX( INDEX, TOTALN )

 INPUTS:
        INDEX -> An index array, e.g. previously generated by a
              WHERE command (may be -1)

        TOTALN -> the number of elements in the reference data
              set, i.e. totaln = n_elements(index)+n_elements(result)

 KEYWORD PARAMETERS:
        None

 OUTPUTS:
        RESULT -> an integer array with all indices that were NOT
              in index or -1 if index was complete

 SUBROUTINES:
        None

 REQUIREMENTS:
        None

 NOTES:
        The function returns -1 if one of the following errors occurs:
        - invalid number of arguments
        - index variable is undefined
        - totaln is less than n_elements(index)
        - totaln less or equal 1, i.e. no associated data
        The last error does not produce an error message, since this
        feature was found to be very useful (in EXPLORE, the widget based
        interactive data explorer)

 EXAMPLE:
        DATA   = FINDGEN( 50 )
        INDEX  = WHERE( DATA ge 25 )
        INVERS = INV_INDEX( INDEX, N_ELEMENTS( DATA ) )
        PRINT, INVERS
           0  1  2  3  4  5  6  7  8  9
          10 11 12 13 14 15 16 17 18 19
          20 21 22 23 24

             ; Find the elements of DATA that are greater than 25
             ; and then print the inverse condition

 MODIFICATION HISTORY:
        mgs, 10 May 1997: VERSION 1.00
        mgs, 18 Aug 1997: - added template and check if n_elements(index) eq 0
        mgs, 05 Apr 1999: - bug fix: needed to make sure result is type long
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/general/inv_index.pro)</STRONG><P>
<HR>
 
<A NAME="IN_RANGE">
<H2>IN_RANGE</H2></A>
<A HREF="#INV_INDEX">[Previous Routine]</A>
<A HREF="#ISALGEBRAIC (FUNCTION)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        IN_RANGE

 PURPOSE:
        IN_RANGE checks to see if an input value lies
        between a minimum value and a maximum value.

 CATEGORY:
        General

 CALLING SEQUENCE:
        RESULT = IN_RANGE(VALUE, MINVAL, MAXVAL)

 INPUTS:
        VALUE  -> The value to be checked
        MINVAL -> The minimum value 
        MAXVAL -> The maximum value

 KEYWORD PARAMETERS:

 OUTPUTS:
       If MINVAL <= VALUE <= MAXVAL, IN_RANGE returns 0
       If VALUE < MINVAL,            IN_RANGE returns 1
       If VALUE > MAXVAL,            IN_RANGE returns 1 

 SUBROUTINES:
       None

 REQUIREMENTS:
       None

 EXAMPLE: 
        IF ( NOT IN_RANGE( VALUE, 0, 100 ) ) $
           THEN PRINT, 'VALUE is not in between 0-100'

             ; Print a message if VALUE lies outside
             ; of the range 0-100
   
  
 MODIFICATION HISTORY:
        bmy, 24 Sep 1997: VERSION 1.00
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10
                          - Updated comments

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/general/in_range.pro)</STRONG><P>
<HR>
 
<A NAME="ISALGEBRAIC (FUNCTION)">
<H2>ISALGEBRAIC (FUNCTION)</H2></A>
<A HREF="#IN_RANGE">[Previous Routine]</A>
<A HREF="#ISALNUM (FUNCTION)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        ISALGEBRAIC (function)

 PURPOSE:
        Locates the position of algebraic characters in a string
        (e.g. locations that are EITHER digits '.' OR +/- signs).

 CATEGORY:
        Strings

 CALLING SEQUENCE:
        Result = ISALGEBRAIC( S [, Keywords ] )

 INPUTS:
        S -> The string to be tested.  

 KEYWORD PARAMETERS:

 OUTPUTS:
        Result -> The value of the function.  RESULT is an index array
            (integer) that contains as many elements as S has 
            characters.  If S is a single character, then RESULT will 
            be scalar. Where RESULT = 1, the corresponding characters 
            in S are algebraic.

 SUBROUTINES:

 REQUIREMENTS:
        None

 NOTES:
        None

 EXAMPLE:
        print, ISALGEBRAIC( '-100;+100' )
            ; prints 1 1 1 1 0 1 1 1 1 

 MODIFICATION HISTORY:
        bmy, 17 Nov 1998: VERSION 1.00
        mgs, 17 Nov 1998: - removed INVERT keyword. It's 
                            simply 1-isalgebraic
                          - added test for '.'
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/strings/isalgebraic.pro)</STRONG><P>
<HR>
 
<A NAME="ISALNUM (FUNCTION)">
<H2>ISALNUM (FUNCTION)</H2></A>
<A HREF="#ISALGEBRAIC (FUNCTION)">[Previous Routine]</A>
<A HREF="#ISALPHA (FUNCTION)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        ISALNUM (function)

 PURPOSE:
        IDL analog to the 'isalnum' routine in C.  Locates 
        alphanumeric characters ( A...Z, a...z, 0..9 ) in a string.

 CATEGORY:
        Strings

 CALLING SEQUENCE:
        Result = ISALNUM( S )

 INPUTS:
        S  -> The string to be tested.  

 KEYWORD PARAMETERS:
        None

 OUTPUTS:
        Result -> The value of the function.  RESULT is an index array
                  that contains as many elements as S has characters. 
                  If S is a single character, then RESULT will be scalar.
                  Where RESULT = 1, the corresponding characters in S
                  are alphanumeric

 SUBROUTINES:
        ISALPHA (function)
        ISDIGIT (function)

 REQUIREMENTS:

 NOTES:
        None

 EXAMPLE:
        print, isalnum( 'ABCD0123#' )
            ; prints, 1 1 1 1 1 1 1 1 0

        print, isalnum( '#' )
            ; prints 0

 MODIFICATION HISTORY:
        bmy, 01 Jun 1998: VERSION 1.00
        bmy, 02 Jun 1998  - now use BYTE function in where statement
                            instead of hardwired constants
        bmy, 02 Jun 1998  VERSION 1.10
                          - now uses ISALPHA and ISDIGIT
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/strings/isalnum.pro)</STRONG><P>
<HR>
 
<A NAME="ISALPHA (FUNCTION)">
<H2>ISALPHA (FUNCTION)</H2></A>
<A HREF="#ISALNUM (FUNCTION)">[Previous Routine]</A>
<A HREF="#ISDIGIT (FUNCTION)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        ISALPHA (function)

 PURPOSE:
        IDL analog to the 'isalpha' routine in C.  Locates the
        positions of alphabetic characters ( A...Z, a...z ).

 CATEGORY:
        Strings

 CALLING SEQUENCE:
        RESULT = ISALPHA( S )

 INPUTS:
        S  -> The string to be tested. 

 KEYWORD PARAMETERS:
        None

 OUTPUTS:
        RESULT -> The value of the function.  RESULT is an index array
                  that contains as many elements as S has characters. 
                  If S is a single character, then RESULT will be scalar.
                  Where RESULT = 1, the corresponding characters in S
                  are alphabetic.
        
 SUBROUTINES:
        ISUPPER (function)
        ISLOWER (function)

 REQUIREMENTS:
        None

 NOTES:
        None

 EXAMPLE:
        PRINT, ISALPHA( 'ABcd0123' )
          1 1 1 1 0 0 0 0

        PRINT, ISALPHA( '#' )
          0

 MODIFICATION HISTORY:
        bmy, 29 May 1998: VERSION 1.00
        bmy, 01 Jun 1998: - now returns 0 for condition FALSE
                          - fixed bug that allowed byte values from
                            91-96 to be treated as letters
        bmy, 02 Jun 1998  - now use BYTE function in where statement
                            instead of hardwired constants
        bmy, 02 Jun 1998  VERSION 1.10
                          - now uses ISUPPER and ISLOWER 
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/strings/isalpha.pro)</STRONG><P>
<HR>
 
<A NAME="ISDIGIT (FUNCTION)">
<H2>ISDIGIT (FUNCTION)</H2></A>
<A HREF="#ISALPHA (FUNCTION)">[Previous Routine]</A>
<A HREF="#ISGRAPH (FUNCTION)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        ISDIGIT (function)

 PURPOSE:
        IDL analog to the 'isdigit' routine in C.  Locates
        numeric characters ( '0' ... '9') in a string. 

 CATEGORY:
        Strings

 CALLING SEQUENCE:
        RESULT = ISDIGIT( S )

 INPUTS:
        S -> The string to be tested.  

 KEYWORD PARAMETERS:
        None

 OUTPUTS:
        RESULT -> The value of the function.  RESULT is an index array
                  that contains as many elements as S has characters. 
                  If S is a single character, then RESULT will be scalar.
                  Where RESULT = 1, the corresponding characters in S
                  are numeric.

 SUBROUTINES:
        None

 REQUIREMENTS:
        None

 NOTES:
        None

 EXAMPLE:
        print, isdigit( '3001ABcd' )
            ; prints, 1 1 1 1 0 0 0 0

        print, isdigit( '#' )
            ; prints 0

 MODIFICATION HISTORY:
        bmy, 29 May 1998: VERSION 1.00
        bmy, 01 Jun 1998: - now returns 0 for condition FALSE
        bmy, 02 Jun 1998  - now use BYTE function in where statement
                            instead of hardwired constants
        bmy, 02 Jun 1998  VERSION 1.10
                          - now can analyze an entire string
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/strings/isdigit.pro)</STRONG><P>
<HR>
 
<A NAME="ISGRAPH (FUNCTION)">
<H2>ISGRAPH (FUNCTION)</H2></A>
<A HREF="#ISDIGIT (FUNCTION)">[Previous Routine]</A>
<A HREF="#ISLEAP (FUNCTION)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        ISGRAPH (function)

 PURPOSE:
        IDL analog to the 'isgraph' routine in C.  Locates all
        graphics characters in a string.

 CATEGORY:
        Strings

 CALLING SEQUENCE:
        RESULT = ISGRAPH( S ) 

 INPUTS:
        S  -> The string to be tested.  

 KEYWORD PARAMETERS:
        None

 OUTPUTS:
        RESULT -> The value of the function.  RESULT is an index array
                  that contains as many elements as S has characters. 
                  If S is a single character, then RESULT will be scalar.
                  Where RESULT = 1, the corresponding characters in S
                  are graphics characters.

 SUBROUTINES:
        None

 REQUIREMENTS:

 NOTES:
        Graphics characters are printing characters (i.e. they can be
        seen on the screen or on a printout) but EXCLUDE the 
        space ( ' ' ) character.

 EXAMPLE:
        print, isgraph( 'ABCD !#~%' )
          1 1 1 1 0 1 1 1 1

        print, isgraph( string( 9B ) )  ; horizontal tab
          0

 MODIFICATION HISTORY:
        bmy, 01 Jun 1998: VERSION 1.00
        bmy, 02 Jun 1998  - now use BYTE function in where statement
                            instead of hardwired constants
        bmy, 02 Jun 1998  VERSION 1.10
                          - now can analyze an entire string
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/strings/isgraph.pro)</STRONG><P>
<HR>
 
<A NAME="ISLEAP (FUNCTION)">
<H2>ISLEAP (FUNCTION)</H2></A>
<A HREF="#ISGRAPH (FUNCTION)">[Previous Routine]</A>
<A HREF="#ISLOWER (FUNCTION)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        ISLEAP (function)

 PURPOSE:
        Returns 1 for each year that is a leap year.

 CATEGORY:
        Date & Time

 CALLING SEQUENCE:
        RESULT = ISLEAP( YEAR )

 INPUTS:
        YEAR -> A year or an array of years. Must be "4 digit" years.

 KEYWORD PARAMETERS:
        None

 OUTPUTS:
        RESULT -> An integer value or array with 1 for each 
             year that is a leap year.

 SUBROUTINES:
        None

 REQUIREMENTS:
        None

 NOTES:
        For many purposes one should take a look at built-in
        IDL date functions first (version > 5.0).

 EXAMPLE:
        YEARS = FINDGEN(25) + 1980 
        PRINT, 365 + ISLEAP(YEARS), FORMAT='(10i4)'
          366 365 365 365 366 365 365 365 366 365
          365 365 366 365 365 365 366 365 365 365
          366 365 365 365 366

             ; Compute the number of days in each year
             ; from 1980 to 2005 using ISLEAP to add
             ; either 1 or 0 to 365.

 MODIFICATION HISTORY:
        mgs, 02 Oct 1998: VERSION 1.00
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10
                          - updated comments, cosmetic changes

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/date_time/isleap.pro)</STRONG><P>
<HR>
 
<A NAME="ISLOWER (FUNCTION)">
<H2>ISLOWER (FUNCTION)</H2></A>
<A HREF="#ISLEAP (FUNCTION)">[Previous Routine]</A>
<A HREF="#ISOPLETH_MAP">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        ISLOWER (function)

 PURPOSE:
        IDL analog to the 'islower' routine in C.  Locates all 
        lowercase alphabetic characters in a string.

 CATEGORY:
        Strings

 CALLING SEQUENCE:
        RESULT = ISLOWER( S )

 INPUTS:
        S  -> The string to be tested

 KEYWORD PARAMETERS:
        None

 OUTPUTS:
        RESULT -> The value of the function.  RESULT is an index array
                  that contains as many elements as S has characters. 
                  If S is a single character, then RESULT will be scalar.
                  Where RESULT = 1, the corresponding characters in S
                  are lowercase alphabetic.

 SUBROUTINES:
        None

 REQUIREMENTS:

 NOTES:
        None

 EXAMPLE:
        print, islower( 'abcdefG' )
          1  1  1  1  1  1  0

        print, islower( 'A' )
          0

 MODIFICATION HISTORY:
        bmy, 01 Jun 1998: VERSION 1.00
        bmy, 02 Jun 1998: VERSION 1.10
                          - now can analyze entire strings
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/strings/islower.pro)</STRONG><P>
<HR>
 
<A NAME="ISOPLETH_MAP">
<H2>ISOPLETH_MAP</H2></A>
<A HREF="#ISLOWER (FUNCTION)">[Previous Routine]</A>
<A HREF="#ISPRINT (FUNCTION)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        ISOPLETH_MAP

 PURPOSE:
        Plots a 3-D (longitude, latitude, altitude) isopleth of
        a data concentration field atop a world map.

 CATEGORY:
        GAMAP Utilities

 CALLING SEQUENCE:
        ISOPLETH_3D

 INPUTS:
        DATA -> The data array to be plotted.  DATA must be
             3-dimensional.

        XMID, YMID, ZMID -> XMID is the array of longitude grid box
             centers.  YMID is the array of latitude grid box centers.  
             ZMID is the array of altitude grid box centers.  
             ISOPLETH_MAP will be able to label the X, Y, and Z axes
             based on the values of XMID, YMID, ZMID.

 KEYWORD PARAMETERS:
        ISOPLETH -> Value of data for which to show an iso-contour surface.  
             Default is 35.0 [ppbv].

        /LOW -> Set this keyword to display the low side of the iso-contour 
             surface (i.e., the contour surfaces enclose high data values). 
             If this keyword is omitted or is 0, the high side of the 
             contour surface is displayed and the contour encloses low
             data values. If this parameter is incorrectly specified,
             errors in shading will result.  

        TITLE1 -> First line of the title that is to be placed atop the plot
             window.  TITLE is passed explicitly to avoid keyword name
             duplication in the _EXTRA=e facility.  A default title
             string of "Volume Rendering" will be used if TITLE is not
             passed explicitly.
 
        TITLE2 -> Second line of the title string for the top of the plot
             window.  This line should be used for specifying the value
             and units of the isosurface.  A default string such as:
             "ISOSURFACE = 20.000 [ppbv]" will be created if TITLE2 is
             not passed explicitly.  Also, if TITLE2 is not passed 
             explicitly, the format descriptor string passed via the
             FORMAT keyword will be used to determine the number of
             decimal places 

        USTR -> String to specify the units of the isocontour surface
             (e.g. '[ppbv]', '[kg/s]', etc).  Default is a null
             string, ''.

        FORMAT -> Format descriptor string used in generating a default
             value of TITLE2.  Default is '(f14.3)'.

        MPARAM -> A 3 element vector containing values for
             [ P0Lat, P0Lon, Rot ], for the MAP_SET command.  
             Default is [ 0, 0, 0 ]. Elements not specified are 
             automatically set to zero.

        LIMIT -> A four-element vector which specifies the latitude
             and longitude extent of the map.  The elements of LIMIT
             are arranged thus: [ LatMin, LonMin, LatMax, LonMax ].
             Default is to set LIMIT = [ -90, -180, 90, 180 ] (i.e.
             to include the entire globe). P0Lon will be computed
             to fit into the LIMIT range unless it is explicitely
             requested in MParam.

        MCOLOR -> Color index of the map outline and title characters.
             Default is 1 (MYCT black).

        ACOLOR -> Color index of the 3-D axes which surround the map
             plot.  Defaults is 1 (MYCT black).

        [XYZ]MARGIN -> A 2-element array specifying the margin on
             the left (bottom) and right (top) sides of the plot
             window, in units of character size. Defaults are 
             XMARGIN=[ 5, 3 ], YMARGIN=[ 3, 3], ZMARGIN=[ 3, 3 ].
             These are used to put some "white space" into the plot
             window for aesthetic purposes.

        WINPARAM -> An integer vector with up to 5 elements:
             WINPARAM(0) = window number  (if negative, a window
                           will be opened with the /FREE option.
             WINPARAM(1) = X dimension of window in pixels (width)
             WINPARAM(2) = Y dimension of window in pixels (height)

 OUTPUTS:
        A picture will be displayed in the X-window device.

 SUBROUTINES:
        External Subroutines Required:
        ================================
        OPEN_DEVICE     CLOSE_DEVICE
        MULTIPANEL      MAP_LABELS
        TVIMAGE

 REQUIREMENTS:
        References routines from both GAMAP and TOOLS packages

 NOTES:
        (1) Does not quite work for multi-panel plots, due to the 
            screen capturing done in the Z-buffer.  

        (2) Verified that the map and data coincide (bmy, 1/19/01)

 EXAMPLE:
      ISOPLETH_MAP, DATA, XMID, YMID, ZMID, $
         ISOPLETH=40, MPARAM=[0, 180, 0], MCOLOR=1, ACOLOR=1

             ; Will display a 35 [ppbv] isopleth with black
             ; map labels, lines, and axes.  MPARAM is set to
             ; accept longitude values (XMID) in the range of
             ; 0 - 360.  

 MODIFICATION HISTORY:
        bmy, 23 Jan 2001: GAMAP VERSION 1.47
                          - based on example code by David Fanning
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10
        phs, 17 Jul 2008: GAMAP VERSION 2.12
                          - Now set N_COLORS to !D.TBLE_SIZE 
        phs, 17 Jul 2008: GAMAP VERSION 2.13
                          - Bug fix: !D.TBLE_SIZE should be !D.TABLE_SIZE
        phs, 14 Oct 2009: - added AZ (so it is used for surface and
                            not map_set) and ZVALUE keywords
                          - added _EXTRA keyword to open_device for PS
                          - more control over TITLE2
        phs, 29 Oct 2009: GAMAP VERSION 2.14
                          - now draws the fram even if there is no
                            iso-surface
</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/gamap_util/isopleth_map.pro)</STRONG><P>
<HR>
 
<A NAME="ISPRINT (FUNCTION)">
<H2>ISPRINT (FUNCTION)</H2></A>
<A HREF="#ISOPLETH_MAP">[Previous Routine]</A>
<A HREF="#ISSPACE (FUNCTION)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        ISPRINT (function)

 PURPOSE:
        IDL analog to the 'isprint' routine in C.  Returns 1 if
        a character is a printable character (including space).

 CATEGORY:
        Strings

 CALLING SEQUENCE:
        RESULT = ISPRINT( S )

 INPUTS:
        S -> The string to be tested.

 KEYWORD PARAMETERS:
        None

 OUTPUTS:
        RESULT -> The value of the function.  RESULT is an index array
                  that contains as many elements as S has characters. 
                  If S is a single character, then RESULT will be scalar.
                  Where RESULT = 1, the corresponding characters in S
                  are printable.

 SUBROUTINES:
        None

 REQUIREMENTS:

 NOTES:
        Printing characters can be seen on the screen (these exclude
        control characters).

 EXAMPLE:
        print, isprint( '!X3d ' )
          1 1 1 1 0

        print, isprint( string( 9B ) )  ; horizontal tab
          0

 MODIFICATION HISTORY:
        bmy, 01 Jun 1998: VERSION 1.00
        bmy, 02 Jun 1998  - now use BYTE function in where statement
                            instead of hardwired constants
        bmy, 02 Jun 1998: VERSION 1.10
                          - now uses ISGRAPH
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/strings/isprint.pro)</STRONG><P>
<HR>
 
<A NAME="ISSPACE (FUNCTION)">
<H2>ISSPACE (FUNCTION)</H2></A>
<A HREF="#ISPRINT (FUNCTION)">[Previous Routine]</A>
<A HREF="#ISUPPER (FUNCTION)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        ISSPACE (function)

 PURPOSE:
        IDL analog to the 'isspace' routine in C.  Locates 
        white space characters in a string.

 CATEGORY:
        Strings

 CALLING SEQUENCE:
        RESULT = ISSPACE( S ) 

 INPUTS:
        S  -> The string to be tested.  

 KEYWORD PARAMETERS:
        None

 OUTPUTS:
        RESULT -> The value of the function.  RESULT is an index 
             array that contains as many elements as S has 
             characters.  If S is a single character, then RESULT 
             will be scalar.  Where RESULT = 1, the corresponding 
             characters in S are numeric.

 SUBROUTINES:
        None

 REQUIREMENTS:

 NOTES:
        None

 EXAMPLES:
        PRINT, ISSPACE( '     ' )
            1 1 1 1 1

        PRINT, ISSPACE( 'A' )
            0

 MODIFICATION HISTORY:
        bmy, 01 Jun 1998: VERSION 1.00
        bmy, 02 Jun 1998: - now use BYTE function in where statement
                            instead of hardwired constants (where
                            possible)
        bmy, 02 Jun 1998: VERSION 1.10
                          - now can analyze an entire string 
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/strings/isspace.pro)</STRONG><P>
<HR>
 
<A NAME="ISUPPER (FUNCTION)">
<H2>ISUPPER (FUNCTION)</H2></A>
<A HREF="#ISSPACE (FUNCTION)">[Previous Routine]</A>
<A HREF="#IS_DEFINED">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        ISUPPER (function)

 PURPOSE:
        IDL analog to the 'isupper' routine in C.  Locates all 
        uppercase alphabetic characters in a string.

 CATEGORY:
        Strings

 CALLING SEQUENCE:
        RESULT = ISUPPER( S )

 INPUTS:
        S  -> The string to be tested

 KEYWORD PARAMETERS:
        None

 OUTPUTS:
        RESULT -> The value of the function.  RESULT is an index array
                  that contains as many elements as S has characters. 
                  If S is a single character, then RESULT will be scalar.
                  Uppercase alphabetic characters in S are thus
                  denoted by the condition ( RESULT eq 1 ).

 SUBROUTINES:
        None

 REQUIREMENTS:
        Assumes that the ASCII character set is the character set
        installed on the system.  The byte values will be different
        for other character sets such as EBSDIC.  

 NOTES:
        None

 EXAMPLE:
        PRINT, ISUPPER( 'ABCDEFg' )
          1  1  1  1  1  1  0

        PRINT, ISUPPER( 'a' )
          0

 MODIFICATION HISTORY:
        bmy, 01 Jun 1998: VERSION 1.00
        bmy, 02 Jun 1998: VERSION 1.10
                          - now can analyze entire strings
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/strings/isupper.pro)</STRONG><P>
<HR>
 
<A NAME="IS_DEFINED">
<H2>IS_DEFINED</H2></A>
<A HREF="#ISUPPER (FUNCTION)">[Previous Routine]</A>
<A HREF="#IS_DIR (FUNCTION)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        IS_DEFINED

 PURPOSE:
        Tests if a program argument is defined (i.e. if it 
        was passed any value(s) from the calling program).

 CATEGORY:
        General

 CALLING SEQUENCE:
        RESULT = IS_DEFINED( ARG )

 INPUTS:
        ARG -> The argument to be tested.

 KEYWORD PARAMETERS:
        None

 OUTPUTS:
        None

 SUBROUTINES:
        None

 REQUIREMENTS:
        None

 NOTES:
        None

 EXAMPLES:
        (1)
        PRINT, IS_DEFINED( ARG )
           0

             ; Because ARG has not been yet assigned a value,
             ; IS_DEFINED( ARG ) returns 0.
        
        (2)
        ARG = 1
        PRINT, IS_DEFINED( ARG )
           1

             ; Because ARG now has not been yet assigned a value,
             ; IS_DEFINED( ARG ) now returns 1.

 MODIFICATION HISTORY:
  D.Fanning, 02 Jul 1998: INITIAL VERSION
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10
                          - Updated comments, cosmetic changes


</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/general/is_defined.pro)</STRONG><P>
<HR>
 
<A NAME="IS_DIR (FUNCTION)">
<H2>IS_DIR (FUNCTION)</H2></A>
<A HREF="#IS_DEFINED">[Previous Routine]</A>
<A HREF="#IS_SELECTED (FUNCTION)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	 IS_DIR (function)

 PURPOSE:
	 Tests if a directory exists

 CATEGORY:
	 File & I/O

 CALLING SEQUENCE:
	 RESULT = IS_DIR( PATH )

 INPUTS:
        PATH -> The variable to be tested.

 KEYWORD PARAMETERS:
        None

 OUTPUTS:
        RESULT -> =1 if directory exists, =0 otherwise

 SUBROUTINES:
        None

 REQUIREMENTS:
        None

 NOTES:
        None

 EXAMPLE:
	 PRINT, IS_DIR( '~/IDL/tools/' )
           1

	      ; Test the existence of the ~/IDL/tools directory.

 MODIFICATION HISTORY:
    R.Bauer, 26 Jan 1999: INITIAL VERSION
                          - from Forschungszentrum Juelich GmbH ICG-1
        bmy, 24 May 2007: TOOLS VERSION 2.06
                          - updated comments
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/file_io/is_dir.pro)</STRONG><P>
<HR>
 
<A NAME="IS_SELECTED (FUNCTION)">
<H2>IS_SELECTED (FUNCTION)</H2></A>
<A HREF="#IS_DIR (FUNCTION)">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
        IS_SELECTED (function)

 PURPOSE:
        Return a boolean vector with 1 for each element of VAR
        that is contained in SELECTION. This is a generalization
        of WHERE(VAR eq value) in that value can be an array
        instead of a single value.

 CATEGORY:
        General

 CALLING SEQUENCE:
        INDEX = IS_SELECTED(VAR,SELECTION)

 INPUTS:
        VAR -> The data vector

        SELECTION -> A vector with chosen values. If no selection
            is given, the function returns a vector with all entries
            set to zero.

 KEYWORD PARAMETERS:
        none

 OUTPUTS:
        INDEX -> An integer vector of length n_elements(VAR) 
             that contains 1 for each element of VAR that has
             one of the SELECTION values.

 SUBROUTINES:
        None

 REQUIREMENTS:
        None

 NOTES:
        None

 EXAMPLES:
        (1)
        A = [ 1, 1, 1, 2, 2, 3 ]
        B = [ 2, 3 ]
        PRINT, IS_SELECTED( A, B )
           0 0 0 1 1 1

        (2)
        PRINT, WHERE( IS_SELECTED( A, B ) )
           3 4 5

        ; (i.e. indices of A that correspond to a value of 2 or 3)
        ; equivalent to:
        print,where(A eq 2 or A eq 3)

 MODIFICATION HISTORY:
        mgs, 19 Aug 1998: VERSION 1.00
  bmy & phs, 13 Jul 2007: GAMAP VERSION 2.10

</PRE><P>
<STRONG>(See /n/home09/ryantosca/IDL/gamap2/general/is_selected.pro)</STRONG><P>
<HR>
 
</body>
</html>
